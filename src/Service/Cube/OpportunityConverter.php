<?php

namespace App\Service\Cube;

use App\Dto\Cube\CubeOpportunityData;
use App\Entity\Asset;
use App\Entity\Cost;
use App\Entity\CostCategory;
use App\Entity\Income;
use App\Entity\IncomeCategory;
use App\Repository\CompanyRepository;
use App\Repository\CostCategoryRepository;
use App\Repository\IncomeCategoryRepository;
use Doctrine\ORM\EntityManagerInterface;

use App\Entity\LocalLaw;

class OpportunityConverter
{
    public function __construct(
        private readonly EntityManagerInterface $entityManager,
        private readonly IncomeCategoryRepository $incomeCategoryRepository,
        private readonly CostCategoryRepository $costCategoryRepository,
        private readonly CompanyRepository $companyRepository
    ) {}

    /**
     * Converte un'opportunità in un'entità finanziaria (Income o Cost) collegata a un Asset.
     */
    public function convert(CubeOpportunityData $opportunity, Asset $asset, array $overrides = []): Income|Cost
    {
        return match ($opportunity->type) {
            'TRADE' => $this->createTradePurchase($opportunity, $asset, $overrides),
            'FREIGHT' => $this->createFreightIncome($opportunity, $asset, $overrides),
            'PASSENGERS' => $this->createPassengersIncome($opportunity, $asset, $overrides),
            'MAIL' => $this->createMailIncome($opportunity, $asset, $overrides),
            'CONTRACT' => $this->createContractIncome($opportunity, $asset, $overrides),
            default => throw new \InvalidArgumentException("Tipo opportunità non supportato: {$opportunity->type}")
        };
    }

    private function createTradePurchase(CubeOpportunityData $opp, Asset $asset, array $overrides = []): Cost
    {
        $category = $this->getCostCategory('TRADE');
        $cost = new Cost();
        // Link to FinancialAccount
        $cost->setFinancialAccount($asset->getFinancialAccount());
        $cost->setUser($asset->getUser());
        $cost->setCostCategory($category);
        $cost->setTitle("Trade Purchase: {$opp->details['goods']}");
        $cost->setAmount((string)$opp->amount);
        $cost->setPaymentDay($opp->details['start_day'] ?? 1);
        $cost->setPaymentYear($opp->details['start_year'] ?? 1105);
        $cost->setTargetDestination($opp->details['destination'] ?? null);

        if (!empty($overrides['local_law_id'])) {
            $law = $this->entityManager->getRepository(LocalLaw::class)->find($overrides['local_law_id']);
            if ($law) {
                $cost->setLocalLaw($law);
            }
        }

        $company = null;
        if (!empty($opp->details['company_id'])) {
            $company = $this->companyRepository->find($opp->details['company_id']);
        }

        if (!$company && !empty($overrides['patron_role_id']) && !empty($opp->details['patron'])) {
            $roleRepo = $this->entityManager->getRepository(\App\Entity\CompanyRole::class);
            $role = $roleRepo->find($overrides['patron_role_id']);
            if ($role) {
                $company = new \App\Entity\Company();
                $company->setName($opp->details['patron']);
                $company->setCompanyRole($role);
                $company->setUser($asset->getUser());
                $company->setIsAutoGenerated(true);
                $company->setContact($opp->details['patron'] . ' contact');
                $company->setSignLabel($opp->details['patron']);
                $this->entityManager->persist($company);
            }
        }

        if ($company) {
            $cost->setCompany($company);
        } elseif (!empty($opp->details['patron'])) {
            $cost->setNote("Supplier/Patron: " . $opp->details['patron'] . "\nLocation: " . ($opp->details['origin'] ?? 'Unknown'));
        } else {
            $cost->setNote("Location: " . ($opp->details['origin'] ?? 'Unknown'));
        }

        $cost->setDetailItems([[
            'description' => $opp->details['goods'],
            'quantity' => (float)$opp->details['tons'],
            'cost' => $opp->amount / max(1, $opp->details['tons']), // Unit Price
            'markup_estimate' => $opp->details['markup_estimate'] ?? 1.50, // Critical for TradePricer
            'target_market' => $opp->details['destination'] ?? null,
            'origin_hex' => $opp->details['origin_hex'] ?? 'Unknown'
        ]]);

        $this->entityManager->persist($cost);
        return $cost;
    }

    private function getCostCategory(string $code): CostCategory
    {
        $category = $this->costCategoryRepository->findOneBy(['code' => $code]);
        if (!$category) {
            // Se non esiste, blocchiamo tutto perché i dati di riferimento sono essenziali
            throw new \RuntimeException("Cost Category '$code' not found in database.");
        }
        return $category;
    }

    private function createContractIncome(CubeOpportunityData $opp, Asset $asset, array $overrides = []): Income
    {
        $category = $this->getIncomeCategory('CONTRACT');
        $income = $this->createBaseIncome($opp, $asset, $category, $overrides);

        $details = [
            'jobType' => $opp->details['mission_type'] ?? 'Mission',
            'objective' => $opp->summary,
            'patron' => $opp->details['patron'] ?? null,
            'location' => $opp->details['origin'] ?? 'Unknown',
            'startDay' => $income->getSigningDay(),
            'startYear' => $income->getSigningYear(),
        ];

        if (!empty($overrides['deadline_day'])) {
            $details['deadlineDay'] = (int)$overrides['deadline_day'];
            $details['deadlineYear'] = (int)($overrides['deadline_year'] ?? $income->getSigningYear());
        }

        $income->setDetails($details);
        return $income;
    }

    private function createBaseIncome(CubeOpportunityData $opp, Asset $asset, IncomeCategory $category, array $overrides = []): Income
    {
        $income = new Income();
        $user = $asset->getUser();
        // Link to FinancialAccount instead of Asset
        $income->setFinancialAccount($asset->getFinancialAccount());
        $income->setUser($user);
        $income->setIncomeCategory($category);
        $income->setTitle($opp->summary);
        $income->setAmount((string)$opp->amount);
        $income->setStatus(Income::STATUS_SIGNED);

        // Location & Date from Context or Overrides
        $income->setSigningLocation($opp->details['origin'] ?? 'Unknown');
        $income->setSigningDay((int)($overrides['day'] ?? ($overrides['startDay'] ?? ($opp->details['start_day'] ?? 1))));
        $income->setSigningYear((int)($overrides['year'] ?? ($overrides['startYear'] ?? ($opp->details['start_year'] ?? 1105))));

        // Mappatura Patron/Company
        $company = null;
        if (!empty($opp->details['company_id'])) {
            $company = $this->companyRepository->find($opp->details['company_id']);
        }

        if (!$company && !empty($overrides['patron_role_id']) && !empty($opp->details['patron'])) {
            $roleRepo = $this->entityManager->getRepository(\App\Entity\CompanyRole::class);
            $role = $roleRepo->find($overrides['patron_role_id']);
            if ($role) {
                $company = new \App\Entity\Company();
                $company->setName($opp->details['patron']);
                $company->setCompanyRole($role);
                $company->setUser($user);
                $company->setIsAutoGenerated(true);
                $company->setContact($opp->details['patron'] . ' contact');
                $company->setSignLabel($opp->details['patron']);
                $this->entityManager->persist($company);
            }
        }

        if ($company) {
            $income->setCompany($company);
        } elseif (!empty($opp->details['patron'])) {
            $income->setPatronAlias($opp->details['patron']);
        }

        $this->entityManager->persist($income);
        return $income;
    }

    private function getIncomeCategory(string $code): IncomeCategory
    {
        $category = $this->incomeCategoryRepository->findOneBy(['code' => $code]);
        if (!$category) {
            throw new \RuntimeException("Income Category '$code' not found.");
        }
        return $category;
    }

    private function createFreightIncome(CubeOpportunityData $opp, Asset $asset, array $overrides = []): Income
    {
        $category = $this->getIncomeCategory('FREIGHT');
        $income = $this->createBaseIncome($opp, $asset, $category, $overrides);

        $income->setDetails([
            'cargoQty' => ($opp->details['tons'] ?? 0) . " tons",
            'destination' => $opp->details['destination'] ?? 'Unknown',
            'origin' => $opp->details['origin'] ?? 'Unknown',
            'cargoDescription' => $opp->details['cargo_type'] ?? 'General Goods',
            'pickupDay' => $income->getSigningDay(),
            'pickupYear' => $income->getSigningYear(),
        ]);

        return $income;
    }

    private function createPassengersIncome(CubeOpportunityData $opp, Asset $asset, array $overrides = []): Income
    {
        $category = $this->getIncomeCategory('PASSENGERS');
        $income = $this->createBaseIncome($opp, $asset, $category, $overrides);

        $income->setDetails([
            'qty' => $opp->details['pax'] ?? 0,
            'classOrBerth' => $opp->details['class'] ?? 'Standard',
            'destination' => $opp->details['destination'] ?? 'Unknown',
            'origin' => $opp->details['origin'] ?? 'Unknown',
            'departureDay' => $income->getSigningDay(),
            'departureYear' => $income->getSigningYear(),
        ]);

        return $income;
    }

    private function createMailIncome(CubeOpportunityData $opp, Asset $asset, array $overrides = []): Income
    {
        $category = $this->getIncomeCategory('MAIL');
        $income = $this->createBaseIncome($opp, $asset, $category, $overrides);

        $income->setDetails([
            'packageCount' => $opp->details['containers'] ?? 0,
            'totalMass' => (string)($opp->details['tons'] ?? 0),
            'destination' => $opp->details['destination'] ?? 'Unknown',
            'origin' => $opp->details['origin'] ?? 'Unknown',
            'mailType' => 'Official Priority',
            'dispatchDay' => $income->getSigningDay(),
            'dispatchYear' => $income->getSigningYear(),
        ]);

        return $income;
    }
}
